"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("unorm");
const idna_uts46_hx_1 = require("idna-uts46-hx");
const crypto_1 = require("../crypto");
const hex_1 = require("../hex");
const constatnts_1 = require("./constatnts");
function normalizeEnsName(...parts) {
    let result = null;
    let name = parts
        .filter((part) => !!part)
        .join(constatnts_1.ENS_NAME_SEPARATOR)
        .split(constatnts_1.ENS_NAME_SEPARATOR)
        .map((part) => part.toLowerCase().trim())
        .filter((part) => !!part)
        .join(constatnts_1.ENS_NAME_SEPARATOR);
    if (name) {
        try {
            name = idna_uts46_hx_1.toAscii(name.toLowerCase(), {
                transitional: true,
                useStd3ASCII: true,
            });
        }
        catch (err) {
            name = null;
        }
        if (name) {
            result = name;
        }
    }
    return result;
}
exports.normalizeEnsName = normalizeEnsName;
function getEnsNameInfo(...parts) {
    let result = null;
    const name = normalizeEnsName(...parts);
    if (name) {
        result = {
            name,
            nameHash: getEnsNameHash(name),
            label: null,
            labelHash: null,
            rootNode: null,
        };
        const parts = name.split(constatnts_1.ENS_NAME_SEPARATOR);
        if (parts.length > 1) {
            const label = parts[0];
            const name = parts.slice(1).join(constatnts_1.ENS_NAME_SEPARATOR);
            if (label && name) {
                result = Object.assign({}, result, { label, labelHash: getEnsLabelHash(label), rootNode: {
                        name,
                        nameHash: getEnsNameHash(name),
                    } });
            }
        }
    }
    return result;
}
exports.getEnsNameInfo = getEnsNameInfo;
function getEnsNameHash(name) {
    let result = null;
    if (name) {
        let node = Buffer.alloc(32, 0);
        const parts = name
            .split(constatnts_1.ENS_NAME_SEPARATOR)
            .map((part) => crypto_1.sha3(part))
            .reverse();
        for (const part of parts) {
            node = crypto_1.sha3(node, part);
        }
        result = hex_1.anyToHex(node, { add0x: true });
    }
    return result;
}
exports.getEnsNameHash = getEnsNameHash;
function getEnsLabelHash(label) {
    let result = null;
    if (label) {
        result = hex_1.anyToHex(crypto_1.sha3(label), { add0x: true });
    }
    return result;
}
exports.getEnsLabelHash = getEnsLabelHash;
